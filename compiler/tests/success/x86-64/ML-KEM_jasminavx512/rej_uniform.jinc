require "params.jinc"
u8 ru_ones_s = 1;
u8 ru_mask_s = 0xFFF;
u8[64] idx_rej = {0, 1, 1, 2, 3, 4, 4, 5,
6, 7, 7, 8, 9, 10, 10, 11,
12, 13, 13, 14, 15, 16, 16, 17,
18, 19, 19, 20, 21, 22, 22, 23,
24, 25, 25, 26, 27, 28, 28, 29,
30, 31, 31, 32, 33, 34, 34, 35,
36, 37, 37, 38, 39, 40, 40, 41,
42, 43, 43, 44, 45, 46, 46, 47};
u8[32] idx256_rej = {0, 1, 1, 2, 3, 4, 4, 5,
6, 7, 7, 8, 9, 10, 10, 11,
12, 13, 13, 14, 15, 16, 16, 17,
18, 19, 19, 20, 21, 22, 22, 23};
u8[16] idx128_rej = {0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 10, 10, 11};


fn _rej_uniform_avx(reg ptr u16[MLKEM_N] rp, reg ptr u8[REJ_UNIFORM_AVX_BUFLEN] buf) -> reg u64, reg ptr u16[MLKEM_N]
{
    reg u512 bound mask;
    reg u256 bound256 mask256;
    reg u128 bound128 mask128;
    reg u512 idx;
    reg u256 idx256;
    reg u128 idx128;
    reg u512 f0 g0;
    reg u256 f1 g1;
    reg u128 f2, g2;
    idx128 = idx128_rej[u128 0];
    idx256 = idx256_rej[u256 0];
    idx = idx_rej[u512 0];
    reg u64 pos ctr;
    reg bool b;
    reg u16 val1 val2;
    // __mmask32 cmp32;
    // __mmask16 cmp16;
    // __mmask8  cmp8;
    // const __mmask32 mmask = _cvtu32_mask32(0xAAAAAAAA);
    ?{ "<=u" = b } = #CMP_64(ctr, MLKEM_N - 32);
    fl1 = #SETcc(b);

    ?{ "<=u" = b } = #CMP_64(pos, REJ_UNIFORM_AVX_BUFLEN - 48);
    fl2 = #SETcc(b);

    _, _, _, _, b = #TEST_8(fl1, fl2);
    while(!b)
    {
        f0 = buf.[u512 (int)pos];
        f0 = #VPERMB_512(idx, f0);
        g0 = #VPSRL_32u16(f0, 4);
        // f0 = _mm512_mask_blend_epi16(mmask, f0, g0);
        f0 = #VPAND_512(f0, mask);
        pos += 48;

        // cmp32 = _mm512_cmplt_epi16_mask(f0, bound);   //( a[i+15:i] < b[i+15:i] ) ? 1 : 0
        // _mm512_mask_compressstoreu_epi16(&r[ctr], cmp32, f0);
        ctr += #POPCNT_32(cmp32);
    }
    ?{ "<=u" = b } = #CMP_64(ctr, MLKEM_N - 16);
    fl1 = #SETcc(b);

    ?{ "<=u" = b } = #CMP_64(pos, REJ_UNIFORM_AVX_BUFLEN - 24);
    fl2 = #SETcc(b);

    _, _, _, _, b = #TEST_8(fl1, fl2);
    while(!b)
    {
        f1 = buf.[u256 (int)pos];
        f1 = #VPERMB_512(idx256, f1);
        g1 = #VPSRL_32u16(f1, 4);
        // f1 = _mm256_mask_blend_epi16((__mmask16)mmask, f1, g1);
        f1 = #VPAND_256(f1, mask256);
        pos += 24;
        // cmp16 = _mm256_cmplt_epi16_mask(f1, bound256);   //( a[i+15:i] < b[i+15:i] ) ? 1 : 0
        // _mm256_mask_compressstoreu_epi16(&r[ctr], cmp16, f1);
        ctr += #POPCNT_32(cmp16);
    }
    ?{ "<=u" = b } = #CMP_64(ctr, MLKEM_N - 8);
    fl1 = #SETcc(b);

    ?{ "<=u" = b } = #CMP_64(pos, REJ_UNIFORM_AVX_BUFLEN - 12);
    fl2 = #SETcc(b);

    _, _, _, _, b = #TEST_8(fl1, fl2);
    while(!b)
    {
        f2 = buf.[u256 (int)pos];
        f2 = #VPERMB_512(idx128, f2);
        g2 = #VPSRL_32u16(f2, 4);
        // f2 = _mm_mask_blend_epi16((__mmask8)mmask, f2, g2);
        f2 = #VPAND_128(f2, mask128);
        pos += 12;
        // cmp8 = _mm_cmplt_epi16_mask(f2, bound128);   //( a[i+15:i] < b[i+15:i] ) ? 1 : 0
        // _mm_mask_compressstoreu_epi16(&r[ctr], cmp8, f2);
        ctr += #POPCNT_32(cmp8);
    }
    ?{ "<=u" = b } = #CMP_64(ctr, MLKEM_N);
    fl1 = #SETcc(b);

    ?{ "<=u" = b } = #CMP_64(pos, REJ_UNIFORM_AVX_BUFLEN - 3);
    fl2 = #SETcc(b);

    _, _, _, _, b = #TEST_8(fl1, fl2);
    while(!b)
    {
        val1 = (16u)buf[pos];
        t = (16u)buf[pos + 1];
        val2 = t;
        val2 >>= 4;
        t &= 0x0F;
        t <<= 8;
        val1 |= t;

        t = (16u)buf[pos + 2];
        t <<= 4;
        val2 |= t;
        pos += 3;

        if val1 < MLKEM_Q{
            rp[ctr] = val1;
            ctr += 1;
        }
        if val2 < MLKEM_Q{
            if(ctr < MLKEM_N)
            {
                rp[ctr] = val2;
                ctr += 1;
            }
        }
    }
    return ctr, rp;
}

inline
fn __rej_uniform(reg ptr u16[MLKEM_N] rp, reg u64 offset, reg ptr u8[SHAKE128_RATE] buf, inline int buflen) ->  reg u64, stack u16[MLKEM_N]
{
  reg u16 val0 val1;
  reg u16 t;
  reg u64 pos ctr;
  reg u8 fl1 fl2;
  reg bool b;

  ctr = offset;
  pos = 0;

  ?{ "<=u" = b }= #CMP_64(ctr, MLKEM_N - 1);
  fl1 = #SETcc(b);

  ?{ "<=u" = b } = #CMP_64(pos, buflen - 3);
  fl2 = #SETcc(b);

  _, _, _, _, b = #TEST_8(fl1, fl2);

  while(!b)
  {
    val0 = (16u)buf[(int)pos];
    pos += 1;

    t   = (16u)buf[(int)pos];
    val1 = t;
    val1 >>= 4;

    t &= 0x0F;
    t <<= 8;
    val0 |= t;
    pos += 1;

    t   = (16u)buf[(int)pos];
    t <<= 4;
    val1 |= t;
    pos += 1;

    if(val0 < MLKEM_Q)
    {
      rp[(int)ctr] = val0;
      ctr += 1;
    }

    if(ctr < MLKEM_N)
    {
      if(val1 < MLKEM_Q)
      {
        rp[(int)ctr] = val1;
        ctr += 1;
      }
    }

    ?{ "<=u" = b } = #CMP_64(ctr, MLKEM_N - 1);
    fl1 = #SETcc(b);

    ?{ "<=u" = b } = #CMP_64(pos, buflen - 3);
    fl2 = #SETcc(b);

    _, _, _, _, b = #TEST_8(fl1, fl2);
  }

  return ctr, rp;
}
