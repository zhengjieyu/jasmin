require "params.jinc"
require "indcpa.jazz"
require "fips202.jinc"

inline fn __crypto_kem_keypair_jazz(reg u64 pkp, reg u64 skp)
{
    stack u8[32] h_pk;
    stack u8[MLKEM_SYMBYTES] rb;
    stack u64 s_skp s_pkp;
    reg u64 t64;
    inline int i;

    s_pkp = pkp;
    s_skp = skp;
    __indcpa_keypair(pkp, skp);

    skp = s_skp;
    skp += MLKEM_POLYVECBYTES;
    pkp = s_pkp;

    for i=0 to MLKEM_INDCPA_PUBLICKEYBYTES/8
    {
        t64 = (u64)[pkp + 8*i];
        (u64)[skp] = t64;
        skp += 8;
    }

    s_skp = skp;
    pkp = s_pkp;
    t64 = MLKEM_INDCPA_PUBLICKEYBYTES;
    h_pk = _isha3_256(h_pk, pkp, t64);
    skp = s_skp;

    for i=0 to 4
    {
        t64 = h_pk[u64 i];
        (u64)[skp] = t64;
        skp += 8;
    }

    rb = #randombytes(rb);

    for i=0 to MLKEM_SYMBYTES/8
    {
        t64 = rb[u64 i];
        (u64)[skp] = t64;
        skp += 8;
    }
}

inline
fn __crypto_kem_enc_jazz(reg u64 ctp, reg u64 shkp, reg u64 pkp)
{
  stack u8[MLKEM_SYMBYTES * 2] buf kr;
  stack u8[MLKEM_SYMBYTES] rb;
  stack u64 s_pkp s_ctp s_shkp;
  reg u64 t64;
  inline int i;

  s_pkp = pkp;
  s_ctp = ctp;
  s_shkp = shkp;

  rb = #randombytes(rb);

  for i=0 to MLKEM_SYMBYTES/8
  {
    t64 = rb[u64 i];
    kr[u64 i] = t64;
  }
  buf[0:32] = _isha3_256_32(buf[0:32], kr[0:MLKEM_SYMBYTES]);

  pkp = s_pkp;

  t64 = MLKEM_PUBLICKEYBYTES;
  buf[MLKEM_SYMBYTES:32] = _isha3_256(buf[MLKEM_SYMBYTES:32], pkp, t64);

  kr = _isha3_512_64(kr, buf);

  pkp = s_pkp;

  __indcpa_enc_0(s_ctp, buf[0:MLKEM_INDCPA_MSGBYTES], pkp, kr[MLKEM_SYMBYTES:MLKEM_SYMBYTES]);

  ctp = s_ctp;
  t64 = MLKEM_INDCPA_BYTES;
  kr[MLKEM_SYMBYTES:32] = _isha3_256(kr[MLKEM_SYMBYTES:32], ctp, t64);

  shkp = s_shkp;
  t64 = MLKEM_SSBYTES;
  _shake256_64(shkp, t64, kr);
}

inline
fn __crypto_kem_dec_jazz(reg u64 shkp, reg u64 ctp, reg u64 skp)
{
  stack u8[MLKEM_INDCPA_BYTES] ctpc;
  stack u8[2*MLKEM_SYMBYTES] kr buf;
  stack u64 s_skp s_ctp s_shkp;
  reg u64 pkp hp zp t64 cnd;
  inline int i;

  s_shkp = shkp;
  s_ctp = ctp;

  buf[0:MLKEM_INDCPA_MSGBYTES] = __indcpa_dec(buf[0:MLKEM_INDCPA_MSGBYTES], ctp, skp);

  hp = #LEA(skp + 32); //hp = skp + 32;
  hp += 24 * MLKEM_K * MLKEM_N>>3;

  for i=0 to MLKEM_SYMBYTES/8
  {
    t64 = (u64)[hp + 8*i];
    buf.[u64 MLKEM_SYMBYTES + 8*i] = t64;
  }

  s_skp = skp;

  kr = _isha3_512_64(kr, buf);

  pkp = s_skp;
  pkp += 12 * MLKEM_K * MLKEM_N>>3;

  ctpc = __indcpa_enc_1(ctpc, buf[0:MLKEM_INDCPA_MSGBYTES], pkp, kr[MLKEM_SYMBYTES:MLKEM_SYMBYTES]);

  ctp = s_ctp;
  cnd = __verify(ctp, ctpc);

  zp = s_skp;
  zp += 64;
  zp += 24 * MLKEM_K * MLKEM_N>>3;
  kr[0:MLKEM_SYMBYTES] = __cmov(kr[0:MLKEM_SYMBYTES], zp, cnd);

  t64 = MLKEM_INDCPA_BYTES;
  kr[MLKEM_SYMBYTES:32] = _isha3_256(kr[MLKEM_SYMBYTES:32], ctp, t64);

  shkp = s_shkp;
  t64 = MLKEM_SSBYTES;
  _shake256_64(shkp, t64, kr);
}
